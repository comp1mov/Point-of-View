<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spatial Memory Fragment - Point of View</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', sans-serif;
            overflow: hidden;
            background: #000;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        @supports (padding: env(safe-area-inset-top)) {
            body {
                padding: 0 !important;
            }
            #canvas-container {
                width: 100vw;
                height: 100vh;
                padding: 0 !important;
                margin: 0 !important;
            }
        }
        
        /* Loading Screen */
        #loading-overlay {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            color: #fff;
            padding: 20px;
            padding-top: calc(20px + env(safe-area-inset-top, 0px));
            padding-bottom: calc(20px + env(safe-area-inset-bottom, 0px));
            box-sizing: border-box;
        }
        
        #loading-overlay.hidden {
            display: none;
        }
        
        .loading-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            max-width: 90vw;
        }
        
        #loading-title {
            font-size: 14px;
            letter-spacing: 3px;
            text-transform: uppercase;
            opacity: 0.8;
            margin-bottom: 30px;
            font-weight: 300;
            line-height: 1.6;
        }
        
        

        #loading-title-main,
        #loading-title-meta {
            display: block;
        }

        #loading-title-meta.hidden {
            display: none;
        }
#loading-description {
            margin-bottom: 40px;
            font-size: 14px;
            opacity: 0.8;
            line-height: 1.8;
            font-weight: 300;
        }
        
        #loading-time {
            font-size: 14px;
            opacity: 0.7;
        }
        
        #loading-location {
            font-size: 16px;
            opacity: 0.9;
            margin: 4px 0;
        }
        
        #loading-place {
            font-size: 14px;
            opacity: 0.7;
        }
        
        #loading-text {
            font-size: 24px;
            letter-spacing: 4px;
            animation: pulse 1.5s ease-in-out infinite;
            margin-bottom: 12px;
            font-weight: 300;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1.0; }
        }
        
        #loading-progress {
            font-size: 16px;
            opacity: 0.7;
            margin-bottom: 40px;
            font-weight: 300;
        }
        
        #loading-credits {
            font-size: 14px;
            opacity: 0.6;
            line-height: 1.8;
            font-weight: 300;
            text-align: center;
        }
        
        #loading-credits a {
            color: #fff;
            text-decoration: none;
            opacity: 0.6;
            transition: opacity 0.3s;
        }
        
        #loading-credits a:hover {
            opacity: 1.0;
            animation: pulse 1.5s ease-in-out infinite;
        }
        
        /* Controls Hint - Compact Box */
        #controls-hint {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.25);
            backdrop-filter: blur(4px);
            padding: 0px 0px;
            border-radius: 2px;
            display: none;
            z-index: 9999;
            color: #fff;
            font-weight: 300;
            text-align: left;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        #controls-hint.show {
            display: block;
            opacity: 1;
        }
        
        #controls-hint.fade-out {
            opacity: 0;
        }
        
        .control-section {
            margin-bottom: 20px;
        }
        
        .control-section:last-child {
            margin-bottom: 0;
        }
        
        .control-title {
            font-size: 14px;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 8px;
            opacity: 1.0;
            font-weight: 400;
        }
        
        .control-inputs {
            font-size: 13px;
            opacity: 0.7;
            line-height: 1.6;
            padding-left: 12px;
        }
    

        /* Corner UI */
        #corner-ui {
            position: fixed;
            right: 14px;
            bottom: 14px;
            z-index: 10000;
            display: flex;
            gap: 10px;
            align-items: center;
            pointer-events: auto;
        }
        #corner-heart {
            color: #fff;
            opacity: 0.75;
            font-size: 14px;
            line-height: 1;
            user-select: none;
        }
        #corner-help {
            width: 28px;
            height: 28px;
            border-radius: 2px;
            background: rgba(0, 0, 0, 0.25);
            border: 1px solid rgba(255, 255, 255, 0.25);
            color: #fff;
            cursor: pointer;
            font-size: 15px;
            line-height: 1;
            padding: 0;
            opacity: 0.85;
        }
        #corner-help:hover {
            opacity: 1.0;
        }

        /* Help Panel */
        #help-panel {
            position: fixed;
            right: 14px;
            bottom: 52px;
            width: 280px;
            max-width: calc(100vw - 28px);
            background: rgba(0, 0, 0, 0.25);
            backdrop-filter: blur(60px);
            border-radius: 2px;
            padding: 10px 10px;
            z-index: 10000;
            color: #fff;
            display: none;
        }
        #help-panel.show {
            display: block;
        }
        .help-header {
            display: flex;
            gap: 10px;
            align-items: flex-start;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        .help-scan {
            min-width: 0;
        }
        #help-title-main {
            font-size: 13px;
            letter-spacing: 1.5px;
            text-transform: uppercase;
            opacity: 0.95;
            margin-bottom: 2px;
        }
        #help-title-meta {
            font-size: 12px;
            opacity: 0.75;
            margin-bottom: 8px;
        }
        #help-location, #help-place, #help-points {
            font-size: 12px;
            opacity: 0.7;
            line-height: 1.35;
        }
        #help-close {
            background: transparent;
            border: 0;
            color: #fff;
            opacity: 0.7;
            cursor: pointer;
            font-size: 16px;
            line-height: 16px;
            padding: 2px 6px;
            border-radius: 2px;
        }
        #help-close:hover {
            opacity: 1.0;
            background: rgba(255, 255, 255, 0.08);
        }

    
        /* Mobile adjustments (iOS Safari centers 100vh lower than visible area) */
        @media (max-width: 600px) {
            #loading-overlay {
                justify-content: flex-start;
            }
            .loading-content {
                margin-top: calc(10vh + env(safe-area-inset-top, 0px));
            }
        }

    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="corner-ui">
        <div id="corner-heart"></div>
        <button id="corner-help" type="button" aria-label="Help">?</button>
    </div>
    
    <!-- Loading Overlay -->
    <div id="loading-overlay">
        <div class="loading-content">
            <div id="loading-title">
                <div id="loading-title-main">MEMORY FRAGMENT</div>
                <div id="loading-title-meta">17:33 2025</div>
            </div>
            
            <div id="loading-description">
                <div id="loading-time"></div>
                <div id="loading-location"></div>
                <div id="loading-place"></div>
            </div>
            
            <div id="loading-text">LOADING</div>
            <div id="loading-progress">0%</div>
            
            <div id="loading-credits">
                scanned by <a href="https://grisha-tsvetkov.com/" target="_blank">Grisha Tsvetkov</a><br>
                <a href="https://www.instagram.com/post.pointillism/" target="_blank">@post.pointillism</a>
            </div>
        </div>
    </div>
    
    <!-- Controls Hint (compact box) -->
    <div id="controls-hint">
        <div class="control-section">
            <div class="control-title">ROTATE</div>
            <div class="control-inputs">
                1 finger<br>
                Left click + drag
            </div>
        </div>
        
        <div class="control-section">
            <div class="control-title">PAN</div>
            <div class="control-inputs">
                2 fingers<br>
                Right click + drag
            </div>
        </div>
        
        <div class="control-section">
            <div class="control-title">ZOOM</div>
            <div class="control-inputs">
                Pinch<br>
                Scroll wheel
            </div>
        </div>
    </div>

    <!-- Help Panel (manual) -->
    <div id="help-panel">
        <div class="help-header">
            <div class="help-scan">
                <div id="help-title-main"></div>
                <div id="help-title-meta"></div>
                <div id="help-location"></div>
                <div id="help-place"></div>
                            <div id="help-points"></div>
</div>
            <button id="help-close" type="button" aria-label="Close">Ã—</button>
        </div>
        <div class="help-body" id="help-body">
            <!-- content is cloned from controls-hint via JS -->
        </div>
    </div>


    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';

        // ============================================
        // CONFIG
        // ============================================
        const CONFIG = {
            // Debug Mode - skip loading & hints for fast iteration
            debugMode: false,  // Set to true for quick testing!
            
            // Intro Animation - Radial Reveal
            introAnimation: {
                enabled: true,
                duration: 30000,
                rotationDegrees: 0,
                
                // Center Point
                centerPoint: [0, 0, 0],
                showCenterDebug: false,
                
                // Scatter & Assembly (SIMULTANEOUS)
                scatterEffect: true,
                scatterShape: 'sphere',
                scatterAmount: 1.2,
                scatterDistanceLimit: 0.3,  // Max distance from original position
                quantizeStart: 0.0,
                quantizeEnd: 0.0,
                quantizeDelay: 0.0,          // When quantize starts (0-1)
                quantizeDuration: 0.1,       // How long quantize takes (0-1)
                scatterSeed: 22,
                assemblyWaveThickness: 0.9,
                assemblyWaveOffset: 0.4,
                
                // Point Size Wave
                pointSizeWave: false,
                pointSizeStart: 1.0,
                pointSizePeak: 1.0,
                pointSizeWaveThickness: 0.1,
                pointSizeWaveOffset: 0.5,
                
                // Visual
                rimThickness: 0.05,
                rimColor: '#39FF14',
                hideGridDuringIntro: true
            },
            
            // Twist (separate, constant)
            twist: {
                enabled: false,
                amount: 0,
                axis: 'x',
                length: 1.0
            
            },
            
            loadingScreen: {
                title: 'MEMORY FRAGMENT',
                titleMeta: '19:05 21012026',
                time: '',
                location: 'Gony at Home',
                place: 'Tel Aviv, Israel',
                minLoadingTime: 5000,
                credits: {
                    name: 'Grisha Tsvetkov',
                    website: 'https://grisha-tsvetkov.com/',
                    instagram: 'https://www.instagram.com/post.pointillism/',
                    handle: '@post.pointillism'
                },
                showControlsHint: true,
                controlsHintDuration: 1000
            },
            
            plyUrl: 'https://dl.dropboxusercontent.com/scl/fi/mh9r9orqa2hip7r9sqdit/Scan-at-19.05-Gony-01212026-1.6mln.ply?rlkey=9cfcmf9j2wa3b6h39a9xdhb3s&',
            
            normalizeCloud: true,
            cloudRotation: { x: 0, y: 66, z: 0 },
            cloudRotationSpeed: { x: 0, y: 1, z: 0 },
            cloudScale: { x: 2.0, y: 2.0, z: 2.0 },
            
            cameraPosition: [-1.51, 1.14, 0.41],
            cameraTarget: [-0.20, 0.06, 0.40],
            cameraFOV: 75,
            cameraNear: 0.005,
            cameraFar: 1000,
            
            // OrbitControls safety + "push-through" at min zoom
            orbitMinDistance: 0.1,
            enableCameraPushAtMinZoom: true,
            cameraPushSpeed: 0.00005,

            // Anchor (camera target) visualization
            showAnchor: false,
            // Anchor rendered as a 3D "+" made of thin boxes (so you can control line thickness)
            anchorLineLength: 0.10,      // total length of each axis line (world units)
            anchorLineThickness: 0.005,  // thickness of the lines (world units)
            anchorColor: '#FFFFFF',
            anchorOpacity: 0.6,
            // Legacy (unused by + style)
            anchorSize: 0.03,

            // Corner UI (bottom-right)
            showCornerUI: true,
            cornerCopyrightText: '<3',
            showHelpButton: true,

            pointSize: 0.007,
            randomSize: 0.7,
            
            pointSizeByDistance: true,
            minDistance: 0.0,
            maxDistance: 2.5,
            minPointSize: 0.4,
            maxPointSize: 5.0,
            
            showGrid: true,
            gridSizeX: 7,
            gridSizeZ: 7,
            gridDivisions: 6,
            gridColor: '#FFFFFF',
            gridOffsetX: 0,
            gridOffsetY: -0.97,
            gridOffsetZ: 0,
            gridFadeStart: 0.2,
            gridFadeEnd: 1.0,
            

            // 3D Grid Volume (Lattice)
            showGrid3D: true,
            grid3DSizeX: 14.0,
            grid3DSizeY: 8.0,
            grid3DSizeZ: 14.0,
            grid3DDivX: 6,
            grid3DDivY: 2,
            grid3DDivZ: 3,
            grid3DColor: '#FFFFFF',
            grid3DOpacity: 0.6,
            grid3DOffsetX: 0,
            grid3DOffsetY: -0.98,
            grid3DOffsetZ: 0,
            grid3DFadeStart: 0.05,
            grid3DFadeEnd: 0.95,
            grid3DFadePower: 3.5,
            grid3DFadeRadiusMultX: 1.0,
            grid3DFadeRadiusMultY: 2.0,
            grid3DFadeRadiusMultZ: 1.0,
            
            backgroundColor: '#000000',
        };

        // ============================================
        // INDEXEDDB CACHE
        // ============================================
        const DB_NAME = 'PointCloudCache';
        const DB_VERSION = 1;
        const STORE_NAME = 'plyFiles';

        class PLYCache {
            constructor() {
                this.db = null;
            }

            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve();
                    };
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(STORE_NAME)) {
                            db.createObjectStore(STORE_NAME, { keyPath: 'url' });
                        }
                    };
                });
            }

            async get(url) {
                if (!this.db) await this.init();
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([STORE_NAME], 'readonly');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.get(url);
                    request.onsuccess = () => resolve(request.result?.data);
                    request.onerror = () => reject(request.error);
                });
            }

            async set(url, data) {
                if (!this.db) await this.init();
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.put({ url, data, timestamp: Date.now() });
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }
        }

        const cache = new PLYCache();

        // ============================================
        // SETUP LOADING SCREEN
        // ============================================
        const titleMainEl = document.getElementById('loading-title-main');
        const titleMetaEl = document.getElementById('loading-title-meta');
        if (titleMainEl) titleMainEl.textContent = CONFIG.loadingScreen.title || '';
        if (titleMetaEl) {
            const meta = CONFIG.loadingScreen.titleMeta || '';
            titleMetaEl.textContent = meta;
            titleMetaEl.classList.toggle('hidden', meta.trim().length === 0);
        }

        document.getElementById('loading-time').textContent = CONFIG.loadingScreen.time;
        document.getElementById('loading-location').textContent = CONFIG.loadingScreen.location;
        document.getElementById('loading-place').textContent = CONFIG.loadingScreen.place;


        // ============================================
        // CORNER UI + HELP PANEL
        // ============================================
        const cornerUIEl = document.getElementById('corner-ui');
        const cornerHeartEl = document.getElementById('corner-heart');
        const cornerHelpBtn = document.getElementById('corner-help');

        const helpPanelEl = document.getElementById('help-panel');
        const helpCloseBtn = document.getElementById('help-close');
        const helpBodyEl = document.getElementById('help-body');

        // Show or hide corner UI
        if (cornerUIEl) {
            cornerUIEl.style.display = CONFIG.showCornerUI ? 'flex' : 'none';
        }
        if (cornerHeartEl) {
            cornerHeartEl.textContent = CONFIG.cornerCopyrightText || '';
        }

        // Fill help panel scan info from CONFIG
        const helpTitleMainEl = document.getElementById('help-title-main');
        const helpTitleMetaEl = document.getElementById('help-title-meta');
        const helpLocationEl = document.getElementById('help-location');
        const helpPlaceEl = document.getElementById('help-place');

        const helpPointsEl = document.getElementById('help-points');

        if (helpTitleMainEl) helpTitleMainEl.textContent = CONFIG.loadingScreen.title || '';
        if (helpTitleMetaEl) {
            const meta = CONFIG.loadingScreen.titleMeta || '';
            helpTitleMetaEl.textContent = meta;
            helpTitleMetaEl.style.display = meta.trim().length ? 'block' : 'none';
        }
        if (helpLocationEl) helpLocationEl.textContent = CONFIG.loadingScreen.location || '';
        if (helpPlaceEl) helpPlaceEl.textContent = CONFIG.loadingScreen.place || '';
        if (helpPointsEl) helpPointsEl.textContent = '';

        // Clone controls hint into help panel (so content stays in one place)
        const controlsHintEl = document.getElementById('controls-hint');
        if (controlsHintEl && helpBodyEl) {
            helpBodyEl.innerHTML = controlsHintEl.innerHTML;
        }

        function setHelpPanelVisible(isVisible) {
            if (!helpPanelEl) return;
            helpPanelEl.classList.toggle('show', isVisible);
        }

        if (cornerHelpBtn) {
            cornerHelpBtn.style.display = CONFIG.showHelpButton ? 'block' : 'none';
            cornerHelpBtn.addEventListener('click', () => {
                if (!helpPanelEl) return;
                const isVisible = helpPanelEl.classList.contains('show');
                setHelpPanelVisible(!isVisible);
            });
        }

        if (helpCloseBtn) {
            helpCloseBtn.addEventListener('click', () => setHelpPanelVisible(false));
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') setHelpPanelVisible(false);
        });


        // ============================================
        // SCENE SETUP
        // ============================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(CONFIG.backgroundColor);
        
        const camera = new THREE.PerspectiveCamera(
            CONFIG.cameraFOV,
            window.innerWidth / window.innerHeight,
            CONFIG.cameraNear,
            CONFIG.cameraFar
        );
        camera.position.set(...CONFIG.cameraPosition);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(...CONFIG.cameraTarget);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Prevent OrbitControls from collapsing to radius 0 (gets "stuck"/singular)
        controls.minDistance = Math.max(1e-6, CONFIG.orbitMinDistance);

        // If user tries to zoom-in past minDistance, move camera and target together
        // so it feels like flying forward instead of hitting a wall.
        const _pushDir = new THREE.Vector3();
        renderer.domElement.addEventListener('wheel', (event) => {
            if (!CONFIG.enableCameraPushAtMinZoom) return;
            if (!controls.enabled || !controls.enableZoom) return;

            const zoomIn = event.deltaY < 0;
            if (!zoomIn) return;

            const dist = camera.position.distanceTo(controls.target);
            const minD = controls.minDistance || CONFIG.orbitMinDistance;
            if (dist > minD + 1e-4) return;

            // Intercept OrbitControls wheel dolly
            event.preventDefault();
            event.stopPropagation();

            _pushDir.subVectors(controls.target, camera.position).normalize();
            const push = (-event.deltaY) * CONFIG.cameraPushSpeed;
            camera.position.addScaledVector(_pushDir, push);
            controls.target.addScaledVector(_pushDir, push);

            if (window.anchorMesh) {
                window.anchorMesh.position.copy(controls.target);
            }

            controls.update();
        }, { passive: false, capture: true });


            if (window.grid3DMesh && window.grid3DMesh.material && window.grid3DMesh.material.uniforms && window.grid3DMesh.material.uniforms.uCenter) {
                window.grid3DMesh.updateMatrixWorld();
                window.grid3DMesh.material.uniforms.uCenter.value.setFromMatrixPosition(window.grid3DMesh.matrixWorld);
            }

            controls.update();


        
        // ============================================
        // ANCHOR (camera target) VISUALIZATION
        // ============================================
        
        let anchorMesh = null;
        {
            // 3D "+" anchor using thin boxes, so line thickness is controllable.
            const len = CONFIG.anchorLineLength || 0.40;
            const th  = CONFIG.anchorLineThickness || 0.002;

            const mat = new THREE.MeshBasicMaterial({
                color: new THREE.Color(CONFIG.anchorColor),
                transparent: true,
                opacity: CONFIG.anchorOpacity,
                depthTest: true
            });

            const group = new THREE.Group();

            const gx = new THREE.BoxGeometry(len, th, th);
            const gy = new THREE.BoxGeometry(th, len, th);
            const gz = new THREE.BoxGeometry(th, th, len);

            const mx = new THREE.Mesh(gx, mat);
            const my = new THREE.Mesh(gy, mat);
            const mz = new THREE.Mesh(gz, mat);

            // Make sure it draws on top
            mx.renderOrder = 999;
            my.renderOrder = 999;
            mz.renderOrder = 999;

            group.add(mx, my, mz);
            group.position.copy(controls.target);
            group.visible = !!CONFIG.showAnchor;

            scene.add(group);
            anchorMesh = group;
            window.anchorMesh = anchorMesh;
        }
// ============================================
        // GRID (rectangular support)
        // ============================================
        if (CONFIG.showGrid) {
            const gridSizeX = CONFIG.gridSizeX;
            const gridSizeZ = CONFIG.gridSizeZ;
            
            const grid = new THREE.GridHelper(
                Math.max(gridSizeX, gridSizeZ),
                CONFIG.gridDivisions,
                CONFIG.gridColor,
                CONFIG.gridColor
            );
            grid.position.set(CONFIG.gridOffsetX, CONFIG.gridOffsetY, CONFIG.gridOffsetZ);
            grid.scale.set(gridSizeX / Math.max(gridSizeX, gridSizeZ), 1, gridSizeZ / Math.max(gridSizeX, gridSizeZ));
            
            const gridMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    gridColor: { value: new THREE.Color(CONFIG.gridColor) },
                    fadeStart: { value: CONFIG.gridFadeStart },
                    fadeEnd: { value: CONFIG.gridFadeEnd },
                    gridCenter: { value: new THREE.Vector3(CONFIG.gridOffsetX, CONFIG.gridOffsetY, CONFIG.gridOffsetZ) },
                    gridSizeX: { value: gridSizeX },
                    gridSizeZ: { value: gridSizeZ }
                },
                vertexShader: `
                    uniform vec3 gridCenter;
                    varying vec3 vWorldPos;
                    void main() {
                        vec4 worldPos = modelMatrix * vec4(position, 1.0);
                        vWorldPos = worldPos.xyz;
                        gl_Position = projectionMatrix * viewMatrix * worldPos;
                    }
                `,
                fragmentShader: `
                    uniform vec3 gridColor;
                    uniform float fadeStart;
                    uniform float fadeEnd;
                    uniform vec3 gridCenter;
                    uniform float gridSizeX;
                    uniform float gridSizeZ;
                    varying vec3 vWorldPos;
                    void main() {
                        vec2 centerDist = vec2(
                            (vWorldPos.x - gridCenter.x) / (gridSizeX * 0.5),
                            (vWorldPos.z - gridCenter.z) / (gridSizeZ * 0.5)
                        );
                        float dist = length(centerDist);
                        float alpha = 1.0 - smoothstep(fadeStart, fadeEnd, dist);
                        alpha *= 0.5;
                        gl_FragColor = vec4(gridColor, alpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                side: THREE.DoubleSide
            });
            
            grid.material.dispose();
            grid.material = gridMaterial;
            scene.add(grid);
            window.gridMesh = grid;
        }



        // ============================================
        // 3D GRID VOLUME (LINE LATTICE)
        // ============================================
        if (CONFIG.showGrid3D) {
            const sx = CONFIG.grid3DSizeX;
            const sy = CONFIG.grid3DSizeY;
            const sz = CONFIG.grid3DSizeZ;

            const divX = Math.max(1, Math.floor(CONFIG.grid3DDivX));
            const divY = Math.max(1, Math.floor(CONFIG.grid3DDivY));
            const divZ = Math.max(1, Math.floor(CONFIG.grid3DDivZ));

            const hx = sx * 0.5;
            const hy = sy * 0.5;
            const hz = sz * 0.5;

            const stepX = sx / divX;
            const stepY = sy / divY;
            const stepZ = sz / divZ;

            const positions = [];

            // X-direction lines
            for (let iy = 0; iy <= divY; iy++) {
                const y = -hy + iy * stepY;
                for (let iz = 0; iz <= divZ; iz++) {
                    const z = -hz + iz * stepZ;
                    positions.push(-hx, y, z,  hx, y, z);
                }
            }

            // Y-direction lines
            for (let ix = 0; ix <= divX; ix++) {
                const x = -hx + ix * stepX;
                for (let iz = 0; iz <= divZ; iz++) {
                    const z = -hz + iz * stepZ;
                    positions.push(x, -hy, z,  x, hy, z);
                }
            }

            // Z-direction lines
            for (let ix = 0; ix <= divX; ix++) {
                const x = -hx + ix * stepX;
                for (let iy = 0; iy <= divY; iy++) {
                    const y = -hy + iy * stepY;
                    positions.push(x, y, -hz,  x, y, hz);
                }
            }

            const grid3DGeometry = new THREE.BufferGeometry();
            grid3DGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            grid3DGeometry.computeBoundingSphere();

            const grid3DMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    uColor: { value: new THREE.Color(CONFIG.grid3DColor) },
                    uOpacity: { value: CONFIG.grid3DOpacity },
                    uCenter: { value: new THREE.Vector3(0, 0, 0) },
                    uFadeRadius: { value: new THREE.Vector3(
                        Math.max(0.0001, hx * CONFIG.grid3DFadeRadiusMultX),
                        Math.max(0.0001, hy * CONFIG.grid3DFadeRadiusMultY),
                        Math.max(0.0001, hz * CONFIG.grid3DFadeRadiusMultZ)
                    ) },
                    uFadeStart: { value: CONFIG.grid3DFadeStart },
                    uFadeEnd: { value: CONFIG.grid3DFadeEnd },
                    uFadePower: { value: CONFIG.grid3DFadePower }
                },
                vertexShader: `
                    varying vec3 vWorldPos;
                    void main() {
                        vec4 worldPos = modelMatrix * vec4(position, 1.0);
                        vWorldPos = worldPos.xyz;
                        gl_Position = projectionMatrix * viewMatrix * worldPos;
                    }
                `,
                fragmentShader: `
                    uniform vec3 uColor;
                    uniform float uOpacity;
                    uniform vec3 uCenter;
                    uniform vec3 uFadeRadius;
                    uniform float uFadeStart;
                    uniform float uFadeEnd;
                    uniform float uFadePower;
                    varying vec3 vWorldPos;
                    void main() {
                        vec3 n = abs(vWorldPos - uCenter) / uFadeRadius;
                        float d = length(n);
                        float a = 1.0 - smoothstep(uFadeStart, uFadeEnd, d);
                        a = pow(clamp(a, 0.0, 1.0), uFadePower) * uOpacity;
                        if (a < 0.002) discard;
                        gl_FragColor = vec4(uColor, a);
                    }
                `,
                transparent: true,
                depthWrite: false
            });

            const grid3D = new THREE.LineSegments(grid3DGeometry, grid3DMaterial);
            grid3D.position.set(CONFIG.grid3DOffsetX, CONFIG.grid3DOffsetY, CONFIG.grid3DOffsetZ);
            grid3D.frustumCulled = false;
            scene.add(grid3D);
            grid3D.updateMatrixWorld(true);
            grid3DMaterial.uniforms.uCenter.value.setFromMatrixPosition(grid3D.matrixWorld);
            window.grid3DMesh = grid3D;
        }

        // ============================================
        // SHADERS
        // ============================================
        const vertexShader = `
            uniform float pointSize;
            uniform float randomSize;
            uniform bool pointSizeByDistance;
            uniform float minDistance;
            uniform float maxDistance;
            uniform float minPointSize;
            uniform float maxPointSize;
            uniform vec3 customCameraPos;
            uniform float introRevealRadius;
            uniform float introWaveThickness;
            uniform float introWaveOffset;
            uniform float introPeakSize;
            uniform float introAssemblyRadius;
            uniform float introAssemblyWaveThickness;
            uniform float introAssemblyWaveOffset;
            uniform float introQuantize;
            uniform float introTwistAmount;
            uniform int introTwistAxis;
            uniform float introTwistLength;
            uniform vec3 introCenterPoint;
            
            attribute vec3 color;
            attribute float randomSizeFactor;
            attribute vec3 scatteredPos;
            varying vec3 vColor;
            varying float vDist;
            
            vec3 rotateAroundAxis(vec3 p, vec3 axis, float angle) {
                float c = cos(angle);
                float s = sin(angle);
                float t = 1.0 - c;
                mat3 rot = mat3(
                    t*axis.x*axis.x + c, t*axis.x*axis.y - s*axis.z, t*axis.x*axis.z + s*axis.y,
                    t*axis.x*axis.y + s*axis.z, t*axis.y*axis.y + c, t*axis.y*axis.z - s*axis.x,
                    t*axis.x*axis.z - s*axis.y, t*axis.y*axis.z + s*axis.x, t*axis.z*axis.z + c
                );
                return rot * p;
            }
            
            void main() {
                vColor = color;
                
                vec3 relPos = position - introCenterPoint;
                float realDist = length(relPos);
                float assemblyWaveCenter = introAssemblyRadius - introAssemblyWaveOffset;
                float assemblyProgress = 0.0;
                
                if (introAssemblyRadius > 0.0) {
                    float distFromWave = realDist - assemblyWaveCenter;
                    assemblyProgress = clamp(distFromWave / introAssemblyWaveThickness, 0.0, 1.0);
                    assemblyProgress = 1.0 - assemblyProgress;
                    assemblyProgress = assemblyProgress * assemblyProgress * (3.0 - 2.0 * assemblyProgress);
                }
                
                vec3 quantizedPos = position;
                if (introQuantize > 0.0) {
                    quantizedPos = introCenterPoint + round((position - introCenterPoint) / introQuantize) * introQuantize;
                }
                
                vec3 twistedPos = quantizedPos;
                if (introTwistAmount != 0.0) {
                    vec3 rel = quantizedPos - introCenterPoint;
                    vec3 axis = introTwistAxis == 0 ? vec3(1,0,0) : (introTwistAxis == 1 ? vec3(0,1,0) : vec3(0,0,1));

                    // Proper twist: rotation angle varies along the chosen axis
                    float coord = dot(rel, axis);
                    float safeLen = max(introTwistLength, 0.000001);
                    float angle = (coord / safeLen) * introTwistAmount;

                    twistedPos = introCenterPoint + rotateAroundAxis(rel, axis, angle);
                }

                vec3 finalPos = mix(scatteredPos, twistedPos, assemblyProgress);
                
                vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                vec4 worldPosition = modelMatrix * vec4(finalPos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
                
                vDist = length(finalPos - introCenterPoint);
                
                float finalSize = pointSize;
                
                float waveCenter = introRevealRadius - introWaveOffset;
                float distFromWave = abs(vDist - waveCenter);
                float rawT = 1.0 - clamp(distFromWave / introWaveThickness, 0.0, 1.0);
                float smoothT = rawT * rawT * (3.0 - 2.0 * rawT);
                float waveMult = 1.0 + smoothT * (introPeakSize - 1.0);
                finalSize *= waveMult;
                
                float randomMult = 1.0 + randomSize * (randomSizeFactor - 0.5) * 2.0;
                finalSize *= randomMult;
                
                if (pointSizeByDistance) {
                    float dist = distance(customCameraPos, worldPosition.xyz);
                    float t = clamp((dist - minDistance) / (maxDistance - minDistance), 0.0, 1.0);
                    float distanceMult = mix(minPointSize, maxPointSize, t);
                    finalSize *= distanceMult;
                }
                
                gl_PointSize = finalSize * (300.0 / -mvPosition.z);
            }
        `;

        const fragmentShader = `
            uniform float introRevealRadius;
            uniform float introRimThickness;
            uniform vec3 introRimColor;
            varying vec3 vColor;
            varying float vDist;
            
            void main() {
                vec2 center = gl_PointCoord - vec2(0.5);
                float dist = length(center);
                if (dist > 0.5) discard;
                
                if (vDist > introRevealRadius) discard;
                
                float edgeFade = smoothstep(introRevealRadius - introRimThickness, introRevealRadius, vDist);
                vec3 finalColor = mix(vColor, introRimColor, edgeFade * 0.5);
                vec3 correctedColor = pow(finalColor, vec3(1.0/2.2));
                
                gl_FragColor = vec4(correctedColor, 1.0);
            }
        `;

        // ============================================
        // LOAD WITH CACHE
        // ============================================
        function getCorsProxyUrl(url) {
            if (!url.startsWith('http') || url.includes('corsproxy') || url.includes('allorigins')) {
                return url;
            }
            if (url.includes('dropbox.com')) {
                return url.replace('www.dropbox.com', 'dl.dropboxusercontent.com').replace('&dl=1', '');
            }
            return url;
        }

        async function loadPLY(url) {
            const loadStartTime = Date.now();
            const loadingOverlay = document.getElementById('loading-overlay');
            const loadingProgress = document.getElementById('loading-progress');
            const controlsHint = document.getElementById('controls-hint');
            
            // Debug mode - minimal wait
            const minLoadTime = CONFIG.debugMode ? 100 : CONFIG.loadingScreen.minLoadingTime;
            
            let geometry;

            try {
                const cachedData = await cache.get(url);
                
                if (cachedData) {
                    console.log('âœ… Loading from cache');
                    
                    const loader = new PLYLoader();
                    geometry = loader.parse(cachedData);
                    
                    if (!CONFIG.debugMode) {
                        const startTime = Date.now();
                        const animateProgress = () => {
                            const elapsed = Date.now() - startTime;
                            const progress = Math.min(99, (elapsed / minLoadTime) * 100);
                            loadingProgress.textContent = Math.floor(progress) + '%';
                            
                            if (progress < 99) {
                                requestAnimationFrame(animateProgress);
                            }
                        };
                        animateProgress();
                    }
                    
                } else {
                    console.log('ðŸ“¥ Loading from network');

                    const fileLoader = new THREE.FileLoader();
                    fileLoader.setResponseType('arraybuffer');
                    const arrayBuffer = await new Promise((resolve, reject) => {
                        fileLoader.load(
                            url,
                            (buf) => resolve(buf),
                            (xhr) => {
                                if (!CONFIG.debugMode && xhr.total) {
                                    const percent = Math.min(99, (xhr.loaded / xhr.total) * 100);
                                    loadingProgress.textContent = Math.floor(percent) + '%';
                                }
                            },
                            (error) => reject(error)
                        );
                    });

                    // Save to cache in background, no blocking for the first run
                    cache.set(url, arrayBuffer)
                        .then(() => console.log('ðŸ’¾ Saved to cache'))
                        .catch((err) => console.warn('Cache save failed', err));

                    const loader = new PLYLoader();
                    geometry = loader.parse(arrayBuffer);
                }
                
                processAndDisplayGeometry(geometry);
                
                const elapsedTime = Date.now() - loadStartTime;
                const remainingTime = Math.max(0, minLoadTime - elapsedTime);
                
                await new Promise(resolve => setTimeout(resolve, remainingTime));
                
                if (!CONFIG.debugMode) loadingProgress.textContent = '100%';
                loadingOverlay.classList.add('hidden');
                
                // Intro animation
                if (CONFIG.introAnimation.enabled && !CONFIG.debugMode) {
                    playIntroAnimation();
                } else {
                    showControlsHint();
                }
            } catch (error) {
                console.error('Error loading:', error);
                document.getElementById('loading-text').textContent = 'ERROR';
            }
        }

        function processAndDisplayGeometry(geometry) {
            if (CONFIG.normalizeCloud) {
                geometry.computeBoundingBox();
                const bbox = geometry.boundingBox;
                const center = new THREE.Vector3();
                bbox.getCenter(center);
                
                const size = new THREE.Vector3();
                bbox.getSize(size);
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 2.0 / maxDim;
                
                const positions = geometry.attributes.position;
                for (let i = 0; i < positions.count; i++) {
                    positions.setXYZ(
                        i,
                        (positions.getX(i) - center.x) * scale,
                        (positions.getY(i) - center.y) * scale,
                        (positions.getZ(i) - center.z) * scale
                    );
                }
                positions.needsUpdate = true;
                geometry.computeBoundingBox();
            }
            
            const positions = geometry.attributes.position;
            const randomSizes = new Float32Array(positions.count);
            const scatteredPositions = new Float32Array(positions.count * 3);
            
            function seededRandom(seed) {
                let x = Math.sin(seed++) * 10000;
                return x - Math.floor(x);
            }
            
            let seed = CONFIG.introAnimation.scatterSeed;
            const centerPoint = new THREE.Vector3(...CONFIG.introAnimation.centerPoint);
            
            for (let i = 0; i < positions.count; i++) {
                randomSizes[i] = Math.random();
                
                if (CONFIG.introAnimation.scatterEffect) {
                    const px = positions.getX(i);
                    const py = positions.getY(i);
                    const pz = positions.getZ(i);
                    
                    const limit = CONFIG.introAnimation.scatterDistanceLimit;
                    
                    if (CONFIG.introAnimation.scatterShape === 'sphere') {
                        const theta = seededRandom(seed++) * Math.PI * 2;
                        const phi = Math.acos(2 * seededRandom(seed++) - 1);
                        const r = Math.pow(seededRandom(seed++), 1/3) * limit;
                        
                        scatteredPositions[i * 3] = px + r * Math.sin(phi) * Math.cos(theta);
                        scatteredPositions[i * 3 + 1] = py + r * Math.sin(phi) * Math.sin(theta);
                        scatteredPositions[i * 3 + 2] = pz + r * Math.cos(phi);
                    } else {
                        const angle = seededRandom(seed++) * Math.PI * 2;
                        const radius = seededRandom(seed++) * limit;
                        const height = (seededRandom(seed++) - 0.5) * 2 * limit;
                        
                        scatteredPositions[i * 3] = px + Math.cos(angle) * radius;
                        scatteredPositions[i * 3 + 1] = py + height;
                        scatteredPositions[i * 3 + 2] = pz + Math.sin(angle) * radius;
                    }
                } else {
                    scatteredPositions[i * 3] = positions.getX(i);
                    scatteredPositions[i * 3 + 1] = positions.getY(i);
                    scatteredPositions[i * 3 + 2] = positions.getZ(i);
                }
            }
            geometry.setAttribute('randomSizeFactor', new THREE.BufferAttribute(randomSizes, 1));
            geometry.setAttribute('scatteredPos', new THREE.BufferAttribute(scatteredPositions, 3));
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    pointSize: { value: CONFIG.pointSize },
                    randomSize: { value: CONFIG.randomSize },
                    pointSizeByDistance: { value: CONFIG.pointSizeByDistance },
                    minDistance: { value: CONFIG.minDistance },
                    maxDistance: { value: CONFIG.maxDistance },
                    minPointSize: { value: CONFIG.minPointSize },
                    maxPointSize: { value: CONFIG.maxPointSize },
                    customCameraPos: { value: camera.position },
                    introRevealRadius: { value: 999 },
                    introWaveThickness: { value: CONFIG.introAnimation.pointSizeWaveThickness },
                    introWaveOffset: { value: CONFIG.introAnimation.pointSizeWaveOffset },
                    introPeakSize: { value: CONFIG.introAnimation.pointSizePeak },
                    introAssemblyRadius: { value: 0.0 },
                    introAssemblyWaveThickness: { value: CONFIG.introAnimation.assemblyWaveThickness },
                    introAssemblyWaveOffset: { value: CONFIG.introAnimation.assemblyWaveOffset },
                    introQuantize: { value: CONFIG.introAnimation.quantizeStart },
                    introTwistAmount: { value: CONFIG.twist.enabled ? CONFIG.twist.amount * Math.PI / 180 : 0 },
                    introTwistAxis: { value: CONFIG.twist.axis === 'x' ? 0 : (CONFIG.twist.axis === 'y' ? 1 : 2) },
                    introTwistLength: { value: 1.0 },
                    introCenterPoint: { value: new THREE.Vector3(...CONFIG.introAnimation.centerPoint) },
                    introRimThickness: { value: CONFIG.introAnimation.rimThickness },
                    introRimColor: { value: new THREE.Color(CONFIG.introAnimation.rimColor) }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: false,
                depthTest: true,
                depthWrite: true
            });
            
            const pointCloud = new THREE.Points(geometry, material);

            // Twist length is based on the cloud bounding box extent along the twist axis
            geometry.computeBoundingBox();
            const _bbox = geometry.boundingBox;
            const _size = new THREE.Vector3();
            _bbox.getSize(_size);
            const _axisIdx = material.uniforms.introTwistAxis.value;
            const _extent = _axisIdx === 0 ? _size.x : (_axisIdx === 1 ? _size.y : _size.z);
            const _lenFactor = (typeof CONFIG.twist.length === 'number' && isFinite(CONFIG.twist.length)) ? CONFIG.twist.length : 1.0;
            material.uniforms.introTwistLength.value = Math.max(0.000001, _extent * _lenFactor);

            pointCloud.frustumCulled = false;
            
            window.pointCloudMaterial = material;
            
            pointCloud.rotation.x = CONFIG.cloudRotation.x * Math.PI / 180;
            pointCloud.rotation.y = CONFIG.cloudRotation.y * Math.PI / 180;
            pointCloud.rotation.z = CONFIG.cloudRotation.z * Math.PI / 180;
            pointCloud.scale.set(CONFIG.cloudScale.x, CONFIG.cloudScale.y, CONFIG.cloudScale.z);
            
            scene.add(pointCloud);
            window.pointCloudMesh = pointCloud;
            
            // Update help panel with points count
            const helpPointsEl = document.getElementById('help-points');
            if (helpPointsEl && geometry && geometry.attributes && geometry.attributes.position) {
                const n = geometry.attributes.position.count || 0;
                helpPointsEl.textContent = 'Points: ' + n.toLocaleString();
            }
            if (CONFIG.introAnimation.showCenterDebug) {
                const debugSphere = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05, 16, 16),
                    new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true })
                );
                debugSphere.position.set(...CONFIG.introAnimation.centerPoint);
                scene.add(debugSphere);
            }
            
            geometry.computeBoundingBox();
            const center = new THREE.Vector3();
            geometry.boundingBox.getCenter(center);
            
            if (CONFIG.cameraTarget[0] === 0 && CONFIG.cameraTarget[1] === 0 && CONFIG.cameraTarget[2] === 0) {
                controls.target.copy(center);
                controls.update();
            }
        }

        const finalUrl = getCorsProxyUrl(CONFIG.plyUrl);
        loadPLY(finalUrl);
        
        function playIntroAnimation() {
            const startTime = Date.now();
            const duration = CONFIG.introAnimation.duration;
            const k = Math.PI / 180;

// Final rotation (degrees -> radians)
const finalRotX = CONFIG.cloudRotation.x * k;
const finalRotY = CONFIG.cloudRotation.y * k;
const finalRotZ = CONFIG.cloudRotation.z * k;

// Intro only offsets Y by rotationDegrees (keeps your existing behavior)
const startRotY = finalRotY - (CONFIG.introAnimation.rotationDegrees * k);

// Set initial rotation for intro
window.pointCloudMesh.rotation.x = finalRotX;
window.pointCloudMesh.rotation.y = startRotY;
window.pointCloudMesh.rotation.z = finalRotZ;
            const mat = window.pointCloudMaterial;
            if(CONFIG.introAnimation.hideGridDuringIntro && window.gridMesh) {
                window.gridMesh.material.uniforms.fadeStart.value = 999;
            }
            
            function animateIntro() {
                const elapsed = Date.now() - startTime;
                const t = Math.min(elapsed / duration, 1.0);
                const eased = 1 - Math.pow(1 - t, 3);
                
                mat.uniforms.introRevealRadius.value = eased * 2.0;
                // Base pose driven by intro (absolute), plus constant spin accumulated during intro (variant B)
const baseX = finalRotX;
const baseY = startRotY + (finalRotY - startRotY) * eased;
const baseZ = finalRotZ;

const spinX = (CONFIG.cloudRotationSpeed.x * (elapsed / 1000)) * k;
const spinY = (CONFIG.cloudRotationSpeed.y * (elapsed / 1000)) * k;
const spinZ = (CONFIG.cloudRotationSpeed.z * (elapsed / 1000)) * k;

window.pointCloudMesh.rotation.x = baseX + spinX;
window.pointCloudMesh.rotation.y = baseY + spinY;
window.pointCloudMesh.rotation.z = baseZ + spinZ;
                
                if (CONFIG.introAnimation.scatterEffect) {
                    mat.uniforms.introAssemblyRadius.value = eased * 2.5;
                    
                    const qDelay = CONFIG.introAnimation.quantizeDelay;
                    const qDur = CONFIG.introAnimation.quantizeDuration;
                    const quantizeT = Math.max(0, Math.min(1, (t - qDelay) / qDur));
                    const smoothQ = quantizeT * quantizeT * (3.0 - 2.0 * quantizeT);
                    mat.uniforms.introQuantize.value = CONFIG.introAnimation.quantizeStart * (1.0 - smoothQ) + CONFIG.introAnimation.quantizeEnd * smoothQ;
                }
                
                if(window.gridMesh && CONFIG.introAnimation.hideGridDuringIntro) {
                    window.gridMesh.material.uniforms.fadeStart.value = 0.1 - (1 - eased) * 10;
                }
                
                if(t < 1.0) {
                    requestAnimationFrame(animateIntro);
                } else {
                    mat.uniforms.introRevealRadius.value = 999;
                    mat.uniforms.introAssemblyRadius.value = 999;
                    mat.uniforms.introQuantize.value = 0;
                    if(window.gridMesh) window.gridMesh.material.uniforms.fadeStart.value = CONFIG.gridFadeStart;
                    showControlsHint();
                }
            }
            animateIntro();
        }
        
        function showControlsHint() {
            const controlsHint = document.getElementById('controls-hint');
            if (CONFIG.loadingScreen.showControlsHint) {
                setTimeout(() => {
                    controlsHint.classList.add('show');
                    setTimeout(() => {
                        controlsHint.classList.add('fade-out');
                        setTimeout(() => { controlsHint.style.display = 'none'; }, 500);
                    }, CONFIG.loadingScreen.controlsHintDuration);
                }, 100);
            }
        }

        // ============================================
        // ANIMATION LOOP
        // ============================================
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            
            if (window.pointCloudMaterial) {
                window.pointCloudMaterial.uniforms.customCameraPos.value.copy(camera.position);
            }
            
            if (window.pointCloudMesh) {
                if (CONFIG.cloudRotationSpeed.x !== 0) {
                    window.pointCloudMesh.rotation.x += CONFIG.cloudRotationSpeed.x * deltaTime * Math.PI / 180;
                }
                if (CONFIG.cloudRotationSpeed.y !== 0) {
                    window.pointCloudMesh.rotation.y += CONFIG.cloudRotationSpeed.y * deltaTime * Math.PI / 180;
                }
                if (CONFIG.cloudRotationSpeed.z !== 0) {
                    window.pointCloudMesh.rotation.z += CONFIG.cloudRotationSpeed.z * deltaTime * Math.PI / 180;
                }
            }
            
            if (window.anchorMesh) {
                window.anchorMesh.visible = !!CONFIG.showAnchor;
                window.anchorMesh.position.copy(controls.target);
            }

            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Camera position copy on 'C' key
        window.addEventListener('keydown', (e) => {
            if (e.key === 'c' || e.key === 'C') {
                const pos = camera.position;
                const target = controls.target;
                const configText = `cameraPosition: [${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)}],\ncameraTarget: [${target.x.toFixed(2)}, ${target.y.toFixed(2)}, ${target.z.toFixed(2)}],`;
                
                navigator.clipboard.writeText(configText).then(() => {
                    console.log('%cðŸ“· Camera copied to clipboard!', 'color: #4CAF50; font-size: 14px; font-weight: bold;');
                    console.log(configText);
                }).catch(() => {
                    console.log('%cðŸ“· Camera position:', 'color: #4CAF50; font-size: 14px; font-weight: bold;');
                    console.log(configText);
                });
            }
        });
    </script>
</body>
</html>
