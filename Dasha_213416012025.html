<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spatial Memory Fragment - Point of View</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', sans-serif;
            overflow: hidden;
            background: #000;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        @supports (padding: env(safe-area-inset-top)) {
            body {
                padding: 0 !important;
            }
            #canvas-container {
                width: 100vw;
                height: 100vh;
                padding: 0 !important;
                margin: 0 !important;
            }
        }
        
        /* Loading Screen */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            color: #fff;
            padding: 20px;
        }
        
        #loading-overlay.hidden {
            display: none;
        }
        
        .loading-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            max-width: 90vw;
        }
        
        #loading-title {
            font-size: 14px;
            letter-spacing: 3px;
            text-transform: uppercase;
            opacity: 0.8;
            margin-bottom: 30px;
            font-weight: 300;
            line-height: 1.6;
        }
        
        #loading-description {
            margin-bottom: 40px;
            font-size: 14px;
            opacity: 0.8;
            line-height: 1.8;
            font-weight: 300;
        }
        
        #loading-time {
            font-size: 14px;
            opacity: 0.7;
        }
        
        #loading-location {
            font-size: 16px;
            opacity: 0.9;
            margin: 4px 0;
        }
        
        #loading-place {
            font-size: 14px;
            opacity: 0.7;
        }
        
        #loading-text {
            font-size: 24px;
            letter-spacing: 4px;
            animation: pulse 1.5s ease-in-out infinite;
            margin-bottom: 12px;
            font-weight: 300;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1.0; }
        }
        
        #loading-progress {
            font-size: 16px;
            opacity: 0.7;
            margin-bottom: 40px;
            font-weight: 300;
        }
        
        #loading-credits {
            font-size: 14px;
            opacity: 0.6;
            line-height: 1.8;
            font-weight: 300;
            text-align: center;
        }
        
        #loading-credits a {
            color: #fff;
            text-decoration: none;
            opacity: 0.6;
            transition: opacity 0.3s;
        }
        
        #loading-credits a:hover {
            opacity: 1.0;
            animation: pulse 1.5s ease-in-out infinite;
        }
        
        /* Controls Hint - Compact Box */
        #controls-hint {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            padding: 30px 40px;
            border-radius: 8px;
            display: none;
            z-index: 9999;
            color: #fff;
            font-weight: 300;
            text-align: left;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        #controls-hint.show {
            display: block;
            opacity: 1;
        }
        
        #controls-hint.fade-out {
            opacity: 0;
        }
        
        .control-section {
            margin-bottom: 20px;
        }
        
        .control-section:last-child {
            margin-bottom: 0;
        }
        
        .control-title {
            font-size: 14px;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 8px;
            opacity: 1.0;
            font-weight: 400;
        }
        
        .control-inputs {
            font-size: 13px;
            opacity: 0.7;
            line-height: 1.6;
            padding-left: 12px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <!-- Loading Overlay -->
    <div id="loading-overlay">
        <div class="loading-content">
            <div id="loading-title">
                MEMORY FRAGMENT <br>
                2134022025
            </div>
            
            <div id="loading-description">
                <div id="loading-time">Scan at 17.33</div>
                <div id="loading-location">Oratorio di San Pietro</div>
                <div id="loading-place">Tirano, Italy</div>
            </div>
            
            <div id="loading-text">LOADING</div>
            <div id="loading-progress">0%</div>
            
            <div id="loading-credits">
                scanned by <a href="https://grisha-tsvetkov.com/" target="_blank">Grisha Tsvetkov</a><br>
                <a href="https://www.instagram.com/post.pointillism/" target="_blank">@post.pointillism</a>
            </div>
        </div>
    </div>
    
    <!-- Controls Hint (compact box) -->
    <div id="controls-hint">
        <div class="control-section">
            <div class="control-title">ROTATE</div>
            <div class="control-inputs">
                1 finger<br>
                Left click + drag
            </div>
        </div>
        
        <div class="control-section">
            <div class="control-title">PAN</div>
            <div class="control-inputs">
                2 fingers<br>
                Right click + drag
            </div>
        </div>
        
        <div class="control-section">
            <div class="control-title">ZOOM</div>
            <div class="control-inputs">
                Pinch<br>
                Scroll wheel
            </div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';

        // ============================================
        // CONFIG
        // ============================================
        const CONFIG = {
            // Debug Mode - skip loading & hints for fast iteration
            debugMode: false,  // Set to true for quick testing!
            
            // Intro Animation - Radial Reveal
            introAnimation: {
                enabled: true,
                duration: 35000,
                rotationDegrees: -20,
                
                // Scatter & Assembly
                scatterEffect: false,
                scatterAmount: 3,
                scatterQuantize: 0.2,
                scatterSeed: 42,
                assemblyStart: 0.1,
                assemblyWaveThickness: 0.6,
                assemblyWaveOffset: 0,
                
                // Point Size Wave
                pointSizeWave: true,
                pointSizeStart: 0.0,
                pointSizePeak: 2,
                pointSizeWaveThickness: 0.5,
                pointSizeWaveOffset: 0.0,
                
                // Visual
                rimThickness: 0.2,
                rimColor: '#667eea',
                hideGridDuringIntro: true
            },
            
            loadingScreen: {
                title: 'MEMORY FRAGMENT  ',
                time: 'Scan at 21:34 16:01:2025',
                location: 'Dasha at Kiryat Hamelacha',
                place: 'Tel Aviv, Israel',
                minLoadingTime: 3000,
                credits: {
                    name: 'Grisha Tsvetkov',
                    website: 'https://grisha-tsvetkov.com/',
                    instagram: 'https://www.instagram.com/post.pointillism/',
                    handle: '@post.pointillism'
                },
                showControlsHint: false,
                controlsHintDuration: 6000
            },
            
            plyUrl: 'https://dl.dropboxusercontent.com/scl/fi/f29pm5wztu4a1bugkgk7t/Dasha-Kirata-KM-21.34-Stairs-02_2025-_4mln.ply?rlkey=p5l226ugnh1zsf9ctfgcmwlt9&',
            
            normalizeCloud: true,
            cloudRotation: { x: 0, y: 33, z: 0 },
            cloudRotationSpeed: { x: 0, y: -1, z: 0 },
            cloudScale: { x: 2.0, y: 2.0, z: 2.0 },
            
            cameraPosition: [-1.26, -0.36, -1.11],
            cameraTarget: [0.21, -0.46, -0.80],
            cameraFOV: 75,
            cameraNear: 0.001,
            cameraFar: 1000,
            
            pointSize: 0.008,
            randomSize: 0.7,
            
            pointSizeByDistance: true,
            minDistance: 0.5,
            maxDistance: 4.0,
            minPointSize: 0.8,
            maxPointSize: 2.6,
            
            showGrid: true,
            gridSizeX: 7,
            gridSizeZ: 7,
            gridDivisions: 5,
            gridColor: '#FFFFFF',
            gridOffsetX: 0,
            gridOffsetY: -0.95,
            gridOffsetZ: 0,
            gridFadeStart: 0.1,
            gridFadeEnd: 1.0,
            
            backgroundColor: '#000000',
        };

        // ============================================
        // INDEXEDDB CACHE
        // ============================================
        const DB_NAME = 'PointCloudCache';
        const DB_VERSION = 1;
        const STORE_NAME = 'plyFiles';

        class PLYCache {
            constructor() {
                this.db = null;
            }

            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve();
                    };
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(STORE_NAME)) {
                            db.createObjectStore(STORE_NAME, { keyPath: 'url' });
                        }
                    };
                });
            }

            async get(url) {
                if (!this.db) await this.init();
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([STORE_NAME], 'readonly');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.get(url);
                    request.onsuccess = () => resolve(request.result?.data);
                    request.onerror = () => reject(request.error);
                });
            }

            async set(url, data) {
                if (!this.db) await this.init();
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.put({ url, data, timestamp: Date.now() });
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }
        }

        const cache = new PLYCache();

        // ============================================
        // SETUP LOADING SCREEN
        // ============================================
        document.getElementById('loading-time').textContent = CONFIG.loadingScreen.time;
        document.getElementById('loading-location').textContent = CONFIG.loadingScreen.location;
        document.getElementById('loading-place').textContent = CONFIG.loadingScreen.place;

        // ============================================
        // SCENE SETUP
        // ============================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(CONFIG.backgroundColor);
        
        const camera = new THREE.PerspectiveCamera(
            CONFIG.cameraFOV,
            window.innerWidth / window.innerHeight,
            CONFIG.cameraNear,
            CONFIG.cameraFar
        );
        camera.position.set(...CONFIG.cameraPosition);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(...CONFIG.cameraTarget);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.update();

        // ============================================
        // GRID (rectangular support)
        // ============================================
        if (CONFIG.showGrid) {
            const gridSizeX = CONFIG.gridSizeX;
            const gridSizeZ = CONFIG.gridSizeZ;
            
            const grid = new THREE.GridHelper(
                Math.max(gridSizeX, gridSizeZ),
                CONFIG.gridDivisions,
                CONFIG.gridColor,
                CONFIG.gridColor
            );
            grid.position.set(CONFIG.gridOffsetX, CONFIG.gridOffsetY, CONFIG.gridOffsetZ);
            grid.scale.set(gridSizeX / Math.max(gridSizeX, gridSizeZ), 1, gridSizeZ / Math.max(gridSizeX, gridSizeZ));
            
            const gridMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    gridColor: { value: new THREE.Color(CONFIG.gridColor) },
                    fadeStart: { value: CONFIG.gridFadeStart },
                    fadeEnd: { value: CONFIG.gridFadeEnd },
                    gridCenter: { value: new THREE.Vector3(CONFIG.gridOffsetX, CONFIG.gridOffsetY, CONFIG.gridOffsetZ) },
                    gridSizeX: { value: gridSizeX },
                    gridSizeZ: { value: gridSizeZ }
                },
                vertexShader: `
                    uniform vec3 gridCenter;
                    varying vec3 vWorldPos;
                    void main() {
                        vec4 worldPos = modelMatrix * vec4(position, 1.0);
                        vWorldPos = worldPos.xyz;
                        gl_Position = projectionMatrix * viewMatrix * worldPos;
                    }
                `,
                fragmentShader: `
                    uniform vec3 gridColor;
                    uniform float fadeStart;
                    uniform float fadeEnd;
                    uniform vec3 gridCenter;
                    uniform float gridSizeX;
                    uniform float gridSizeZ;
                    varying vec3 vWorldPos;
                    void main() {
                        vec2 centerDist = vec2(
                            (vWorldPos.x - gridCenter.x) / (gridSizeX * 0.5),
                            (vWorldPos.z - gridCenter.z) / (gridSizeZ * 0.5)
                        );
                        float dist = length(centerDist);
                        float alpha = 1.0 - smoothstep(fadeStart, fadeEnd, dist);
                        alpha *= 0.5;
                        gl_FragColor = vec4(gridColor, alpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                side: THREE.DoubleSide
            });
            
            grid.material.dispose();
            grid.material = gridMaterial;
            scene.add(grid);
            window.gridMesh = grid;
        }

        // ============================================
        // SHADERS
        // ============================================
        const vertexShader = `
            uniform float pointSize;
            uniform float randomSize;
            uniform bool pointSizeByDistance;
            uniform float minDistance;
            uniform float maxDistance;
            uniform float minPointSize;
            uniform float maxPointSize;
            uniform vec3 customCameraPos;
            uniform float introRevealRadius;
            uniform float introWaveThickness;
            uniform float introWaveOffset;
            uniform float introPeakSize;
            uniform float introAssemblyRadius;
            uniform float introAssemblyWaveThickness;
            uniform float introAssemblyWaveOffset;
            
            attribute vec3 color;
            attribute float randomSizeFactor;
            attribute vec3 scatteredPos;
            varying vec3 vColor;
            varying float vDist;
            
            void main() {
                vColor = color;
                
                float realDist = length(position);
                float assemblyWaveCenter = introAssemblyRadius - introAssemblyWaveOffset;
                float assemblyProgress = 0.0;
                
                if (introAssemblyRadius > 0.0) {
                    float distFromWave = realDist - assemblyWaveCenter;
                    assemblyProgress = clamp(distFromWave / introAssemblyWaveThickness, 0.0, 1.0);
                    assemblyProgress = 1.0 - assemblyProgress;
                    assemblyProgress = assemblyProgress * assemblyProgress * (3.0 - 2.0 * assemblyProgress);
                }
                
                vec3 finalPos = mix(scatteredPos, position, assemblyProgress);
                
                vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                vec4 worldPosition = modelMatrix * vec4(finalPos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
                
                vDist = length(finalPos);
                
                float finalSize = pointSize;
                
                float waveCenter = introRevealRadius - introWaveOffset;
                float distFromWave = abs(vDist - waveCenter);
                float rawT = 1.0 - clamp(distFromWave / introWaveThickness, 0.0, 1.0);
                float smoothT = rawT * rawT * (3.0 - 2.0 * rawT);
                float waveMult = 1.0 + smoothT * (introPeakSize - 1.0);
                finalSize *= waveMult;
                
                float randomMult = 1.0 + randomSize * (randomSizeFactor - 0.5) * 2.0;
                finalSize *= randomMult;
                
                if (pointSizeByDistance) {
                    float dist = distance(customCameraPos, worldPosition.xyz);
                    float t = clamp((dist - minDistance) / (maxDistance - minDistance), 0.0, 1.0);
                    float distanceMult = mix(minPointSize, maxPointSize, t);
                    finalSize *= distanceMult;
                }
                
                gl_PointSize = finalSize * (300.0 / -mvPosition.z);
            }
        `;

        const fragmentShader = `
            uniform float introRevealRadius;
            uniform float introRimThickness;
            uniform vec3 introRimColor;
            varying vec3 vColor;
            varying float vDist;
            
            void main() {
                vec2 center = gl_PointCoord - vec2(0.5);
                float dist = length(center);
                if (dist > 0.5) discard;
                
                if (vDist > introRevealRadius) discard;
                
                float edgeFade = smoothstep(introRevealRadius - introRimThickness, introRevealRadius, vDist);
                vec3 finalColor = mix(vColor, introRimColor, edgeFade * 0.5);
                vec3 correctedColor = pow(finalColor, vec3(1.0/2.2));
                
                gl_FragColor = vec4(correctedColor, 1.0);
            }
        `;

        // ============================================
        // LOAD WITH CACHE
        // ============================================
        function getCorsProxyUrl(url) {
            if (!url.startsWith('http') || url.includes('corsproxy') || url.includes('allorigins')) {
                return url;
            }
            if (url.includes('dropbox.com')) {
                return url.replace('www.dropbox.com', 'dl.dropboxusercontent.com').replace('&dl=1', '');
            }
            return url;
        }

        async function loadPLY(url) {
            const loadStartTime = Date.now();
            const loadingOverlay = document.getElementById('loading-overlay');
            const loadingProgress = document.getElementById('loading-progress');
            const controlsHint = document.getElementById('controls-hint');
            
            // Debug mode - minimal wait
            const minLoadTime = CONFIG.debugMode ? 100 : CONFIG.loadingScreen.minLoadingTime;
            
            let geometry;

            try {
                const cachedData = await cache.get(url);
                
                if (cachedData) {
                    console.log('âœ… Loading from cache');
                    
                    const loader = new PLYLoader();
                    geometry = loader.parse(cachedData);
                    
                    if (!CONFIG.debugMode) {
                        const startTime = Date.now();
                        const animateProgress = () => {
                            const elapsed = Date.now() - startTime;
                            const progress = Math.min(100, (elapsed / minLoadTime) * 100);
                            loadingProgress.textContent = Math.floor(progress) + '%';
                            
                            if (progress < 100) {
                                requestAnimationFrame(animateProgress);
                            }
                        };
                        animateProgress();
                    }
                    
                } else {
                    console.log('ðŸ“¥ Loading from network');
                    
                    const loader = new PLYLoader();
                    geometry = await new Promise((resolve, reject) => {
                        loader.load(
                            url,
                            (geo) => resolve(geo),
                            (xhr) => {
                                if (!CONFIG.debugMode) {
                                    const percent = (xhr.loaded / xhr.total * 100).toFixed(0);
                                    loadingProgress.textContent = percent + '%';
                                }
                            },
                            (error) => reject(error)
                        );
                    });
                    
                    const response = await fetch(url);
                    const arrayBuffer = await response.arrayBuffer();
                    await cache.set(url, arrayBuffer);
                    console.log('ðŸ’¾ Saved to cache');
                }
                
                processAndDisplayGeometry(geometry);
                
                const elapsedTime = Date.now() - loadStartTime;
                const remainingTime = Math.max(0, minLoadTime - elapsedTime);
                
                await new Promise(resolve => setTimeout(resolve, remainingTime));
                
                loadingOverlay.classList.add('hidden');
                
                // Intro animation
                if (CONFIG.introAnimation.enabled && !CONFIG.debugMode) {
                    playIntroAnimation();
                } else {
                    showControlsHint();
                }
            } catch (error) {
                console.error('Error loading:', error);
                document.getElementById('loading-text').textContent = 'ERROR';
            }
        }

        function processAndDisplayGeometry(geometry) {
            if (CONFIG.normalizeCloud) {
                geometry.computeBoundingBox();
                const bbox = geometry.boundingBox;
                const center = new THREE.Vector3();
                bbox.getCenter(center);
                
                const size = new THREE.Vector3();
                bbox.getSize(size);
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 2.0 / maxDim;
                
                const positions = geometry.attributes.position;
                for (let i = 0; i < positions.count; i++) {
                    positions.setXYZ(
                        i,
                        (positions.getX(i) - center.x) * scale,
                        (positions.getY(i) - center.y) * scale,
                        (positions.getZ(i) - center.z) * scale
                    );
                }
                positions.needsUpdate = true;
                geometry.computeBoundingBox();
            }
            
            const positions = geometry.attributes.position;
            const randomSizes = new Float32Array(positions.count);
            const scatteredPositions = new Float32Array(positions.count * 3);
            
            function seededRandom(seed) {
                let x = Math.sin(seed++) * 10000;
                return x - Math.floor(x);
            }
            
            let seed = CONFIG.introAnimation.scatterSeed;
            const quantize = CONFIG.introAnimation.scatterQuantize;
            for (let i = 0; i < positions.count; i++) {
                randomSizes[i] = Math.random();
                
                if (CONFIG.introAnimation.scatterEffect) {
                    const angle = seededRandom(seed++) * Math.PI * 2;
                    const radius = seededRandom(seed++) * CONFIG.introAnimation.scatterAmount;
                    const height = (seededRandom(seed++) - 0.5) * 2 * CONFIG.introAnimation.scatterAmount;
                    
                    let x = Math.cos(angle) * radius;
                    let y = height;
                    let z = Math.sin(angle) * radius;
                    
                    if (quantize > 0) {
                        x = Math.round(x / quantize) * quantize;
                        y = Math.round(y / quantize) * quantize;
                        z = Math.round(z / quantize) * quantize;
                    }
                    
                    scatteredPositions[i * 3] = x;
                    scatteredPositions[i * 3 + 1] = y;
                    scatteredPositions[i * 3 + 2] = z;
                } else {
                    scatteredPositions[i * 3] = positions.getX(i);
                    scatteredPositions[i * 3 + 1] = positions.getY(i);
                    scatteredPositions[i * 3 + 2] = positions.getZ(i);
                }
            }
            geometry.setAttribute('randomSizeFactor', new THREE.BufferAttribute(randomSizes, 1));
            geometry.setAttribute('scatteredPos', new THREE.BufferAttribute(scatteredPositions, 3));
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    pointSize: { value: CONFIG.pointSize },
                    randomSize: { value: CONFIG.randomSize },
                    pointSizeByDistance: { value: CONFIG.pointSizeByDistance },
                    minDistance: { value: CONFIG.minDistance },
                    maxDistance: { value: CONFIG.maxDistance },
                    minPointSize: { value: CONFIG.minPointSize },
                    maxPointSize: { value: CONFIG.maxPointSize },
                    customCameraPos: { value: camera.position },
                    introRevealRadius: { value: 999 },
                    introWaveThickness: { value: CONFIG.introAnimation.pointSizeWaveThickness },
                    introWaveOffset: { value: CONFIG.introAnimation.pointSizeWaveOffset },
                    introPeakSize: { value: CONFIG.introAnimation.pointSizePeak },
                    introAssemblyRadius: { value: 0.0 },
                    introAssemblyWaveThickness: { value: CONFIG.introAnimation.assemblyWaveThickness },
                    introAssemblyWaveOffset: { value: CONFIG.introAnimation.assemblyWaveOffset },
                    introRimThickness: { value: CONFIG.introAnimation.rimThickness },
                    introRimColor: { value: new THREE.Color(CONFIG.introAnimation.rimColor) }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: false,
                depthTest: true,
                depthWrite: true
            });
            
            const pointCloud = new THREE.Points(geometry, material);
            pointCloud.frustumCulled = false;
            
            window.pointCloudMaterial = material;
            
            pointCloud.rotation.x = CONFIG.cloudRotation.x * Math.PI / 180;
            pointCloud.rotation.y = CONFIG.cloudRotation.y * Math.PI / 180;
            pointCloud.rotation.z = CONFIG.cloudRotation.z * Math.PI / 180;
            pointCloud.scale.set(CONFIG.cloudScale.x, CONFIG.cloudScale.y, CONFIG.cloudScale.z);
            
            scene.add(pointCloud);
            window.pointCloudMesh = pointCloud;
            
            geometry.computeBoundingBox();
            const center = new THREE.Vector3();
            geometry.boundingBox.getCenter(center);
            
            if (CONFIG.cameraTarget[0] === 0 && CONFIG.cameraTarget[1] === 0 && CONFIG.cameraTarget[2] === 0) {
                controls.target.copy(center);
                controls.update();
            }
        }

        const finalUrl = getCorsProxyUrl(CONFIG.plyUrl);
        loadPLY(finalUrl);
        
        function playIntroAnimation() {
            const startTime = Date.now();
            const duration = CONFIG.introAnimation.duration;
            const finalRot = CONFIG.cloudRotation.y * Math.PI / 180;
            const startRot = finalRot - (CONFIG.introAnimation.rotationDegrees * Math.PI / 180);
            window.pointCloudMesh.rotation.y = startRot;
            const mat = window.pointCloudMaterial;
            if(CONFIG.introAnimation.hideGridDuringIntro && window.gridMesh) {
                window.gridMesh.material.uniforms.fadeStart.value = 999;
            }
            
            function animateIntro() {
                const elapsed = Date.now() - startTime;
                const t = Math.min(elapsed / duration, 1.0);
                const eased = 1 - Math.pow(1 - t, 3);
                
                mat.uniforms.introRevealRadius.value = eased * 2.0;
                window.pointCloudMesh.rotation.y = startRot + (finalRot - startRot) * eased;
                
                if (CONFIG.introAnimation.scatterEffect && t >= CONFIG.introAnimation.assemblyStart) {
                    const assemblyT = (t - CONFIG.introAnimation.assemblyStart) / (1.0 - CONFIG.introAnimation.assemblyStart);
                    mat.uniforms.introAssemblyRadius.value = assemblyT * 2.5;
                }
                
                if(window.gridMesh && CONFIG.introAnimation.hideGridDuringIntro) {
                    window.gridMesh.material.uniforms.fadeStart.value = 0.1 - (1 - eased) * 10;
                }
                
                if(t < 1.0) {
                    requestAnimationFrame(animateIntro);
                } else {
                    mat.uniforms.introRevealRadius.value = 999;
                    mat.uniforms.introAssemblyRadius.value = 999;
                    if(window.gridMesh) window.gridMesh.material.uniforms.fadeStart.value = CONFIG.gridFadeStart;
                    showControlsHint();
                }
            }
            animateIntro();
        }
        
        function showControlsHint() {
            const controlsHint = document.getElementById('controls-hint');
            if (CONFIG.loadingScreen.showControlsHint) {
                setTimeout(() => {
                    controlsHint.classList.add('show');
                    setTimeout(() => {
                        controlsHint.classList.add('fade-out');
                        setTimeout(() => { controlsHint.style.display = 'none'; }, 500);
                    }, CONFIG.loadingScreen.controlsHintDuration);
                }, 100);
            }
        }

        // ============================================
        // ANIMATION LOOP
        // ============================================
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            
            if (window.pointCloudMaterial) {
                window.pointCloudMaterial.uniforms.customCameraPos.value.copy(camera.position);
            }
            
            if (window.pointCloudMesh) {
                if (CONFIG.cloudRotationSpeed.x !== 0) {
                    window.pointCloudMesh.rotation.x += CONFIG.cloudRotationSpeed.x * deltaTime * Math.PI / 180;
                }
                if (CONFIG.cloudRotationSpeed.y !== 0) {
                    window.pointCloudMesh.rotation.y += CONFIG.cloudRotationSpeed.y * deltaTime * Math.PI / 180;
                }
                if (CONFIG.cloudRotationSpeed.z !== 0) {
                    window.pointCloudMesh.rotation.z += CONFIG.cloudRotationSpeed.z * deltaTime * Math.PI / 180;
                }
            }
            
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Camera position copy on 'C' key
        window.addEventListener('keydown', (e) => {
            if (e.key === 'c' || e.key === 'C') {
                const pos = camera.position;
                const target = controls.target;
                const configText = `cameraPosition: [${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)}],\ncameraTarget: [${target.x.toFixed(2)}, ${target.y.toFixed(2)}, ${target.z.toFixed(2)}],`;
                
                navigator.clipboard.writeText(configText).then(() => {
                    console.log('%cðŸ“· Camera copied to clipboard!', 'color: #4CAF50; font-size: 14px; font-weight: bold;');
                    console.log(configText);
                }).catch(() => {
                    console.log('%cðŸ“· Camera position:', 'color: #4CAF50; font-size: 14px; font-weight: bold;');
                    console.log(configText);
                });
            }
        });
    </script>
</body>
</html>
